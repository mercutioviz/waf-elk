filter {
  # Tag likely FIREWALL lines early: PRI optional, " WF " required
  if [message] =~ /^(?:<\d+>)?[^\ ]+\sWF\s/ {
    mutate { add_tag => ["waf_firewall_candidate"] }
  }

  if "waf_firewall_candidate" in [tags] {

    grok {
      match => [
        "message",
        '^(?:<%{POSINT:syslog_pri}>)?%{DATA:un} %{WORD:lt} %{TIMESTAMP_ISO8601:ts} %{ISO8601_TIMEZONE:tz}\s+ %{WORD:sl} %{DATA:ad} %{IP:ci} %{NUMBER:cp:int} %{IP:ai} %{NUMBER:ap:int} %{DATA:ri} %{DATA:rt} %{WORD:at} %{NOTSPACE:fa} \[(?<adl>.*?)\]\s+%{WORD:m} %{NOTSPACE:u} %{NOTSPACE:p} "(?<sid>[^"]*)" "(?<ua>[^"]*)" %{IP:ci_tail} %{NUMBER:cp_tail:int} "(?<au>[^"]*)"\s+(?<cs1>[^ ]*) (?<uid>[^ ]*)'
      ]
      tag_on_failure => ["_waf_firewall_grok_fail"]
    }


    if "_waf_firewall_grok_fail" not in [tags] {
      date {
        match  => [ "ts",
                    "YYYY-MM-dd HH:mm:ss.SSS Z",
                    "YYYY-MM-dd HH:mm:ss.SSSZZ",
                    "YYYY-MM-dd HH:mm:ss.SSS'Z'" ]
        target => "@timestamp"
      }

      # Normalize dashes on quoted fields
      ruby {
        code => '
          ["sid","ua","au","r"].each do |f|
            v = event.get(f)
            event.set(f, nil) if v == "-" || v == "\"-\"" || v == ""
          end
        '
      }

      # Light un-escape inside attack details
      ruby {
        code => '
          v = event.get("adl")
          if v
            v = v.gsub("\\\\\"", "\"").gsub("\\\\\'", "\'").gsub("\\\\=", "=")
            event.set("adl", v)
          end
        '
      }

      mutate {
        rename => {
          "ci" => "[client][ip]"
          "cp" => "[client][port]"
          "ai" => "[destination][ip]"
          "ap" => "[destination][port]"
          "m"  => "[http][request][method]"
          "u"  => "[url][path]"
          "ua" => "[user_agent][original]"
          "r"  => "[http][request][referrer]"
          "ri" => "[rule][id]"
          "rt" => "[rule][category]"
          "ad" => "[rule][name]"
          "adl" => "[rule][description]"
          "at" => "[event][action]"
          "fa" => "[labels][follow_up_action]"
          "un" => "[observer][name]"
        }
        add_field => {
          "[event][category]"         => "intrusion_detection"
          "[event][dataset]"          => "waf.firewall"
          "[labels][severity_label]"  => "%{sl}"
          "[labels][log_type]"        => "%{lt}"
          "[labels][unit_name]"       => "%{[observer][name]}"
        }
      }

      # Protocol hint
      if [p] {
        if [p] =~ /^TLS/ {
          mutate { add_field => { "[tls][version]" => "%{p}" } }
        } else {
          mutate { add_field => { "[network][protocol]" => "%{p}" } }
        }
      }

      # UA + GeoIP
      if [user_agent] and [user_agent][original] {
        useragent { source => "[user_agent][original]" target => "[user_agent]" }
      }
      if [client] and [client][ip] {
        geoip { source => "[client][ip]" target => "[client][geo]" }
      }

      mutate {
        remove_field => ["message","ts","sl","lt","p","@version","debug_raw_message","ci_tail","cp_tail"]
      }

      mutate { add_tag => ["waf_firewall_parsed"] }
    }
  }
}

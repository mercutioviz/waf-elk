filter {
  # Tag likely ACCESS lines early: PRI is optional, " TR " token is required
  if [message] =~ /^(?:<\d+>)?[^\ ]+\sTR\s/ {
    mutate { add_tag => ["waf_access_candidate"] }
  }

  if "waf_access_candidate" in [tags] {
    # Tolerant TR pattern:
    # - q, r: quoted OR unquoted single token (no spaces)
    # - c: quoted OR unquoted WITH spaces; we stop at the next quoted UA using a look-ahead
    # - capture the IP/port right after UA as ci_tail/cp_tail (device repeats client ip/port)
    grok {
      match => [
        "message",
        '^(?:<%{POSINT:syslog_pri}>)?%{DATA:un} %{WORD:lt} %{TIMESTAMP_ISO8601:ts} %{ISO8601_TIMEZONE:tz}\s+%{IP:ai} %{NUMBER:ap:int} %{IP:ci} %{NUMBER:cp:int} "(?<id>[^"]*)" "(?<cu>[^"]*)" %{WORD:m} %{NOTSPACE:p} %{NOTSPACE:h} %{NOTSPACE:v} %{NUMBER:s:int} %{NUMBER:bs:int} %{NUMBER:br:int} %{NUMBER:ch:int} %{NUMBER:tt:int} %{IP:si} %{NUMBER:sp:int} %{NUMBER:st:int} "(?<sid>[^"]*)" %{WORD:rtf} %{WORD:pmf} %{WORD:pf} %{WORD:wmf} %{NOTSPACE:u}\s+(?:"(?<q>[^"]*)"|(?<q>[^ \t]+))\s+(?:"(?<r>[^"]*)"|(?<r>[^ \t]+))\s+(?<c>[^"]*)"(?<ua>[^"]*)"\s+%{IP:ci_tail}\s+%{NUMBER:cp_tail:int}\s+"(?<au>[^"]*)"\s+"(?<cs1>[^"]*)"\s+"(?<cs2>[^"]*)"\s+"(?<cs3>[^"]*)"\s+%{DATA:uid}\s*$'
      ]
      tag_on_failure => ["_waf_access_grok_fail"]
    }

    if "_waf_access_grok_fail" not in [tags] {
      # Timestamp
      date {
        match  => [ "ts",
                    "YYYY-MM-dd HH:mm:ss.SSS Z",
                    "YYYY-MM-dd HH:mm:ss.SSSZZ",
                    "YYYY-MM-dd HH:mm:ss.SSS'Z'" ]
        target => "@timestamp"
      }

      # Coalesce quoted/unquoted q,r,c into single fields and normalize "-" -> nil
      ruby {
        code => '
          { "q" => "q_quoted", "r" => "r_quoted" }.each do |dst, src|
            vq = event.get(src)
            event.set(dst, vq) if vq && vq != ""
            event.remove(src)
          end
          # Prefer quoted cookie if present; else use unquoted (may contain spaces)
          cq = event.get("c_quoted")
          cu = event.get("c_unquoted")
          event.set("c", cq && cq != "" ? cq : cu)
          event.remove("c_quoted")
          event.remove("c_unquoted")

          ["id","cu","sid","q","r","c","ua","au","cs1","cs2","cs3"].each do |f|
            v = event.get(f)
            event.set(f, nil) if v == "-" || v == "\"-\"" || v == ""
          end
        '
      }

      # ECS-like mappings
      mutate {
        rename => {
          "ci" => "[client][ip]"
          "cp" => "[client][port]"
          "ai" => "[destination][ip]"
          "ap" => "[destination][port]"
          "si" => "[server][ip]"
          "sp" => "[server][port]"
          "m"  => "[http][request][method]"
          "s"  => "[http][response][status_code]"
          "ua" => "[user_agent][original]"
          "r"  => "[http][request][referrer]"
          "u"  => "[url][path]"
          "q"  => "[url][query]"
          "h"  => "[url][domain]"
          "v"  => "[http][version]"
        }
        add_field => {
          "[event][category]" => "web"
          "[event][dataset]"  => "waf.access"
          "[observer][name]"  => "%{un}"
        }
      }

      # Protocol hint (TLS vs HTTP)
      if [p] {
        if [p] =~ /^TLS/ {
          mutate { add_field => { "[tls][version]" => "%{p}" } }
        } else {
          mutate { add_field => { "[network][protocol]" => "%{p}" } }
        }
      }

      # UA parsing + GeoIP
      if [user_agent] and [user_agent][original] {
        useragent { source => "[user_agent][original]" target => "[user_agent]" }
      }
      if [client] and [client][ip] {
        geoip { source => "[client][ip]" target => "[client][geo]" }
      }

      # Cleanup: drop duplicates from tail and working fields
      mutate {
        remove_field => ["message","ts","un","lt","@version","debug_raw_message","ci_tail","cp_tail"]
      }

      mutate { add_tag => ["waf_access_parsed"] }
    }
  }
}
